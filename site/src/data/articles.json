[{"what":"F-Algebras reduce data embedded in a structure (Functor) down to a single value","slug":"f-algebras","url":"/articles/recursive/f-algebras","content":"<h1 id=\"f-algebras\">F-Algebras</h1>\n<p><code>Algebra</code> is unfortunately an extremely overloaded term, but here we're going to specifically be talking about <code>F-Algebras</code>. In a nutshell, an <code>F-Algebra</code> is simply any function of type <code>(f a -&gt; a)</code>. Honestly, if that makes sense to you, you can probably stop there and go back to whatever you were trying to do. If you want a bit more background on it feel free to keep reading!</p>\n<p>In the context of the Recursion Schemes <code>F-Algebras</code> are passed to combinators to show them how you'd like to collapse down a single 'layer' of structure. The library can then apply this reduction iteratively until the entire structure has been collapsed.</p>\n<p>Here's an example of an <code>F-Algebra</code> over lists which shows how to fold a single 'layer' of the <code>ListF</code> functor which contains an <code>Int</code> as data, and to combine it with the recursive result of summing the rest of the list. In the <code>Nil</code> case we must still return an <code>Int</code> somehow so we use <code>0</code> as the sum of an empty list is <code>0</code>.</p>\n<p>The signature of our algebra is <code>ListF Int Int -&gt; Int</code> which means the <code>f</code> of this <code>F-Algebra</code> is <code>ListF Int</code> . We provide a way to collapse this structure containing <code>Int</code>s into a single <code>Int</code></p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><span class=\"ot\">sumListFAlgebra ::</span> <span class=\"dt\">ListF</span> <span class=\"dt\">Int</span> <span class=\"dt\">Int</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\">sumListFAlgebra (<span class=\"dt\">Cons</span> val total) <span class=\"fu\">=</span> val <span class=\"fu\">+</span> total</a>\n<a class=\"sourceLine\" id=\"cb1-3\" title=\"3\">sumListFAlgebra <span class=\"dt\">Nil</span>              <span class=\"fu\">=</span> <span class=\"dv\">0</span></a>\n<a class=\"sourceLine\" id=\"cb1-4\" title=\"4\"></a></code></pre></div>\n<p>The Recursion Schemes functions accept algebras as arguments to perform their function, so you can avoid a lot of work by writing a simple algebra which expresses a single step of your problem and let the library figure out the rest for you.</p>","title":"F-Algebras","why":"F-Algebras are typically used as arguments to Recursive recursion-schemes","section":"Recursive"},{"what":"Fold data structures down to a single value","slug":"basic-catamorphisms","url":"/articles/recursive/basic-catamorphisms","content":"<h1 id=\"basic-catamorphisms\">Basic Catamorphisms</h1>\n<p>Welcome! If you think a catamorphism might be what Professor McGonagall does in the Harry Potter books then you're in the right place!</p>\n<p>Catamorphisms are a great place to start on your journey towards understanding recursion schemes as a whole! They aren't as scary as they sound, the prefix <code>cata</code> comes from the Greek word meaning <code>downwards</code>, <code>morph</code> loosely means 'to change from one thing to another' so if we squint a bit we get that <code>catamorphism</code> basically means to reduce something down. Catamorphisms take some 'thing' with an associated 'structure' and reduce it down to some 'thing' with <strong>less</strong> structure.</p>\n<p>Catamorphisms closely resemble the <code>foldr</code> function from <code>Data.List</code>; let's compare the two:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><span class=\"fu\">foldr</span><span class=\"ot\"> ::</span> <span class=\"dt\">Foldable</span> t  <span class=\"ot\">=&gt;</span> (a <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> b)   <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> t a <span class=\"ot\">-&gt;</span> b</a>\n<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\"><span class=\"ot\">cata ::</span>  <span class=\"dt\">Recursive</span> t <span class=\"ot\">=&gt;</span> (<span class=\"dt\">Base</span> t b <span class=\"ot\">-&gt;</span> b)      <span class=\"ot\">-&gt;</span> t   <span class=\"ot\">-&gt;</span> b</a></code></pre></div>\n<p>If we specialize them both to lists we get the following:</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\"><span class=\"fu\">foldr</span><span class=\"ot\"> ::</span> (a <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> b)    <span class=\"ot\">-&gt;</span> b   <span class=\"ot\">-&gt;</span> [a] <span class=\"ot\">-&gt;</span> b</a>\n<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\"><span class=\"ot\">cata  ::</span> (<span class=\"dt\">ListF</span> a b <span class=\"ot\">-&gt;</span> b) <span class=\"ot\">-&gt;</span>        [b] <span class=\"ot\">-&gt;</span> b</a></code></pre></div>\n<p>There are few things we notice right off the bat: the function we pass to each of them is slightly different; <code>foldr</code> explicitly handles the next element <code>a</code> and the accumulator <code>b</code> as arguments as well as passing a <strong>default</strong> <code>b</code> to use in the case that the container is empty. <code>cata</code> leaves you to collect and handle the combination of the accumulated <code>b</code>s from your structure yourself, and to provide your own default behaviour if any of your constructors don't contain any accumulated value (<code>Nil</code> in this case).</p>\n<p>Shifting these concerns into the algebra actually makes this approach more powerful, we have knowledge of the structure we're folding at each step and can make different decisions based on it, possibly handling recursive values differently based on their location in the structure (e.g.Â subtract accumulators in the right branch of a binary tree from those in the left branch).</p>\n<p>Let's write the <code>sum :: [Int] -&gt; Int</code> function using both <code>foldr</code> and <code>cata</code> to see how they compare and get an intuition for folding using algebras.</p>\n<p>Here's the simple <code>foldr</code> version:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\"><span class=\"ot\">sumFoldr ::</span> [<span class=\"dt\">Int</span>] <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb3-2\" title=\"2\">sumFoldr <span class=\"fu\">=</span> <span class=\"fu\">foldr</span> (<span class=\"fu\">+</span>) <span class=\"dv\">0</span></a></code></pre></div>\n<p>Here's the slightly longer <code>cata</code> version</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb4-1\" title=\"1\"><span class=\"ot\">sumCata ::</span> [<span class=\"dt\">Int</span>] <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb4-2\" title=\"2\">sumCata <span class=\"fu\">=</span> cata algebra</a>\n<a class=\"sourceLine\" id=\"cb4-3\" title=\"3\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb4-4\" title=\"4\"><span class=\"ot\">  algebra ::</span> <span class=\"dt\">ListF</span> <span class=\"dt\">Int</span> <span class=\"dt\">Int</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb4-5\" title=\"5\">  <span class=\"co\">-- Here we provide a default value for our base case</span></a>\n<a class=\"sourceLine\" id=\"cb4-6\" title=\"6\">  algebra <span class=\"dt\">Nil</span>               <span class=\"fu\">=</span> <span class=\"dv\">0</span></a>\n<a class=\"sourceLine\" id=\"cb4-7\" title=\"7\">  <span class=\"co\">-- We collapse one step of the list by adding</span></a>\n<a class=\"sourceLine\" id=\"cb4-8\" title=\"8\">  <span class=\"co\">-- the next element to the running total</span></a>\n<a class=\"sourceLine\" id=\"cb4-9\" title=\"9\">  algebra (<span class=\"dt\">Cons</span> next total) <span class=\"fu\">=</span> next <span class=\"fu\">+</span> total</a></code></pre></div>\n<p>So we can see here that the <code>cata</code> version is definitely longer for this particular case, using <code>cata</code> doesn't gain us much when we're operating on lists; but as we continue onwards to more complex structures we find that we have more power using an algebra than we do with the <code>Foldable</code> instance of structures.</p>\n<p>Let's upgrade our Lists to Trees to see how this plays out!</p>\n<p>Here's a data structure representing a <a href=\"https://en.wikipedia.org/wiki/Binary_tree\">Binary Tree</a> where each node contains a value. Notice that we're also deriving a <code>Foldable</code> instance for the structure here using <code>DeriveFoldable</code>.</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb5-1\" title=\"1\"><span class=\"co\">-- Recursive binary tree with data at leaf nodes</span></a>\n<a class=\"sourceLine\" id=\"cb5-2\" title=\"2\"><span class=\"kw\">data</span> <span class=\"dt\">BinTree</span> a <span class=\"fu\">=</span> <span class=\"dt\">Branch</span> a (<span class=\"dt\">BinTree</span> a) (<span class=\"dt\">BinTree</span> a) <span class=\"fu\">|</span> <span class=\"dt\">Empty</span></a>\n<a class=\"sourceLine\" id=\"cb5-3\" title=\"3\">  <span class=\"kw\">deriving</span> (<span class=\"dt\">Show</span>, <span class=\"dt\">Eq</span>, <span class=\"dt\">Foldable</span>)</a></code></pre></div>\n<p>Now we'll write the recursive <code>Functor</code> version of the type for use with recursion schemes where each recursive occurance of the structure is replaced with a new type variable <code>r</code>.</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb6-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">BinTreeF</span> a r <span class=\"fu\">=</span> <span class=\"dt\">BranchF</span> a r r <span class=\"fu\">|</span> <span class=\"dt\">EmptyF</span></a>\n<a class=\"sourceLine\" id=\"cb6-2\" title=\"2\">  <span class=\"kw\">deriving</span> (<span class=\"dt\">Show</span>, <span class=\"dt\">Eq</span>, <span class=\"dt\">Functor</span>)</a>\n<a class=\"sourceLine\" id=\"cb6-3\" title=\"3\"><span class=\"kw\">type</span> <span class=\"kw\">instance</span> <span class=\"dt\">Base</span> (<span class=\"dt\">BinTree</span> a) <span class=\"fu\">=</span> <span class=\"dt\">BinTreeF</span> a</a>\n<a class=\"sourceLine\" id=\"cb6-4\" title=\"4\"></a>\n<a class=\"sourceLine\" id=\"cb6-5\" title=\"5\"><span class=\"kw\">instance</span> <span class=\"dt\">Recursive</span> (<span class=\"dt\">BinTree</span> a) <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb6-6\" title=\"6\">  project <span class=\"dt\">Empty</span> <span class=\"fu\">=</span> <span class=\"dt\">EmptyF</span></a>\n<a class=\"sourceLine\" id=\"cb6-7\" title=\"7\">  project (<span class=\"dt\">Branch</span> a left right) <span class=\"fu\">=</span> <span class=\"dt\">BranchF</span> a left right</a>\n<a class=\"sourceLine\" id=\"cb6-8\" title=\"8\"></a>\n<a class=\"sourceLine\" id=\"cb6-9\" title=\"9\"><span class=\"kw\">instance</span> <span class=\"dt\">Corecursive</span> (<span class=\"dt\">BinTree</span> a) <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb6-10\" title=\"10\">  embed <span class=\"dt\">EmptyF</span> <span class=\"fu\">=</span> <span class=\"dt\">Empty</span></a>\n<a class=\"sourceLine\" id=\"cb6-11\" title=\"11\">  embed (<span class=\"dt\">BranchF</span> a left right) <span class=\"fu\">=</span> <span class=\"dt\">Branch</span> a left right</a></code></pre></div>\n<p>Great! That's a bit more interesting!</p>\n<p>To prove that our recursion schemes and algebras give new power over what Foldable brings we'll attempt to implement some standard tree traversals! If you're unfamiliar with the concept you can read up more about tree traversals on the <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\">Wiki page</a>!</p>\n<p>In short, we want to reduce a tree to a list, but there are several possible orderings to do it!</p>\n<p>It turns out that when we derive the <code>Foldable</code> class, the order of the fields in our constructor actually determines which traversal we get! Since we have the structure <code>Branch a (BinTree a) (BinTree a)</code> GHC will <strong>fold</strong> the 'a' first, then the left branch followed by the right, corresponding to a depth first traversal. That means our implementation of Depth-First-Search using foldable is simply:</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb7-1\" title=\"1\"><span class=\"ot\">depthFirstFoldable ::</span> <span class=\"dt\">BinTree</span> a <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb7-2\" title=\"2\">depthFirstFoldable <span class=\"fu\">=</span> toList</a></code></pre></div>\n<p>Here's the equivalent version using <code>cata</code></p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb8-1\" title=\"1\"><span class=\"ot\">depthFirstCata ::</span> <span class=\"dt\">BinTree</span> a <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb8-2\" title=\"2\">depthFirstCata <span class=\"fu\">=</span> cata algebra</a>\n<a class=\"sourceLine\" id=\"cb8-3\" title=\"3\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb8-4\" title=\"4\"><span class=\"ot\">  algebra ::</span> <span class=\"dt\">BinTreeF</span> a [a] <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb8-5\" title=\"5\">  algebra <span class=\"dt\">EmptyF</span>          <span class=\"fu\">=</span> []</a>\n<a class=\"sourceLine\" id=\"cb8-6\" title=\"6\">  algebra (<span class=\"dt\">BranchF</span> a l r) <span class=\"fu\">=</span> [a] <span class=\"fu\">++</span> l <span class=\"fu\">++</span> r</a></code></pre></div>\n<p>Hopefully that's relatively stright forward! Now for the tricky bit, how do we define an <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\"><em>In Order</em></a> traversal using our Foldable instance? Sorry to break it to ya, but we <em>can't</em>! Our foldable instance only knows how to process all elements, there are no guarantees on ordering and there's no way for us to talk about the <strong>structure</strong> of the data as we fold! Using <code>cata</code> it's easy! Check it out:</p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb9-1\" title=\"1\"><span class=\"ot\">inOrderCata ::</span> <span class=\"dt\">BinTree</span> a <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb9-2\" title=\"2\">inOrderCata <span class=\"fu\">=</span> cata algebra</a>\n<a class=\"sourceLine\" id=\"cb9-3\" title=\"3\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb9-4\" title=\"4\"><span class=\"ot\">  algebra ::</span> <span class=\"dt\">BinTreeF</span> a [a] <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb9-5\" title=\"5\">  algebra <span class=\"dt\">EmptyF</span>          <span class=\"fu\">=</span> []</a>\n<a class=\"sourceLine\" id=\"cb9-6\" title=\"6\">  algebra (<span class=\"dt\">BranchF</span> a l r) <span class=\"fu\">=</span> l <span class=\"fu\">++</span> [a] <span class=\"fu\">++</span> r</a></code></pre></div>\n<p>Hopefully this shows how recursion-schemes and the use of <strong>algebras</strong> helps give us more <strong>power</strong> by having knowledge of our data's <strong>structure</strong> at the cost of a little boiler-plate.</p>","title":"Basic Catamorphisms","why":"Catamorphisms allow you to express recursion elegantly","section":"Recursive"}]