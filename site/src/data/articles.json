[{"what":"Base","slug":"base","sortKey":"1","url":"/articles/data/base","content":"<h1 id=\"base\">Base</h1>\n<p>Reading through type signatures in the <code>recursion-schemes</code> library you'll see many occurances of something like <code>Base t a</code>. <code>Base</code> is a <em>type family</em> (i.e. a function on types which returns a result type based on its arguments). The <code>Base</code> type of some data-type is a variant of the data-type where any slot in the structure which contained a recursive occurance of the type is instead replaced with a new type parameter, and a Functor instance is defined over the new type parameter. This means that <code>Base t</code> will always resolve to a type of kind <code>Type -&gt; Type</code>; i.e. the <code>Base</code> type of a data structure always has at <em>least</em> one type parameter, and has a <code>Functor</code> instance which maps over that type parameter.</p>\n<p>Defining this machinery is what allows the <code>recursion-schemes</code> library to collapse or expand your data one <em>slice</em> at a time. Since the recursive portion of the type is replaced by a type parameter, the library can fill that slot with the result of applying your algebra, allowing you to simply pass a single step of your <a href=\"/articles/recursive/f-algebra\">algebra</a> and have the library handle the iteration for you.</p>\n<p>For an easy-to-understand example of how to build a <code>Base</code> type for your structure take a look at <a href=\"/articles/data/listf\">ListF</a></p>","title":"Base","why":"Each recursive type has a 'Base' where recursion is factored out into a type parameter","section":"Data"},{"what":"ListF","slug":"listf","sortKey":"2","url":"/articles/data/listf","content":"<h1 id=\"listf\">ListF</h1>\n<p><code>ListF</code> is one of the most common <code>Base</code> functors. It's relatively simple and will be coming up in a lot of examples so it's worth taking a bit of time to understand it well. It's also one of the few Base functors which comes for included with the <code>recursion-schemes</code>, but for the sake of pedagogy we'll go ahead and re-implement it here.</p>\n<p>If you've read about the <a href=\"/articles/data/base\"><code>Base</code> type family</a> already you'll have learned that in order to use <code>recursion-schemes</code> on a given data-type we need a version of that data-type where the recursive <em>bits</em> of that type have been replaced with a type parameter. Let's take a look at the definition of the <code>[]</code> type in Haskell and see if we can write <code>ListF</code> on our own:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><span class=\"kw\">data</span> [] a <span class=\"fu\">=</span> [] <span class=\"fu\">|</span> a <span class=\"fu\">:</span> [a]</a></code></pre></div>\n<p>Lists get special treatment in Haskell since they have custom syntax, but taking a look at the definition we can see that there are two constructors, either the empty list (<code>[]</code>) or an element paired with another list! The <code>[a]</code> is what we're looking for, it's an occurance of the data type we're defining within the definition itself! That's the part we need to replace with a type parameter. Let's write <code>ListF</code>, a type that's the same as (see 'isomorphic to') the list type, but with the recursion <strong>factored-out</strong> into a type parameter which we'll call <code>r</code> for <strong>recursive</strong>.</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">ListF</span> a r <span class=\"fu\">=</span> <span class=\"dt\">Nil</span> <span class=\"fu\">|</span> <span class=\"dt\">Cons</span> a r</a>\n<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\">  <span class=\"kw\">deriving</span> (<span class=\"dt\">Show</span>, <span class=\"dt\">Eq</span>, <span class=\"dt\">Functor</span>)</a></code></pre></div>\n<p>And that's it! Note how we've also derived the <code>Functor</code> typeclass for our <code>Base</code> type, which we'll need to do if we plan on using it with <code>recursion-schemes</code>. If <code>ListF</code> wasn't already included for us we'd also want to define it as the <code>Base</code> of <code>[]</code> by writing:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\"><span class=\"kw\">type</span> <span class=\"kw\">instance</span> <span class=\"dt\">Base</span> [a] <span class=\"fu\">=</span> <span class=\"dt\">ListF</span> a</a></code></pre></div>\n<p>Now whenever we write an algebra or coalgebra over <code>ListF</code> we have empty list as our fixed-point, and can hold a piece of data (i.e. an <code>a</code>) alongside a recursively computed result, or the seed for future computation in the <code>r</code> slot!</p>","title":"ListF","why":"ListF is the Base functor for the [] type","section":"Data"},{"what":"Fold data structures down to a single value","slug":"basic-catamorphisms","sortKey":"2","url":"/articles/recursive/basic-catamorphisms","content":"<h1 id=\"basic-catamorphisms\">Basic Catamorphisms</h1>\n<p>Welcome! If you think a catamorphism might be what Professor McGonagall does in the Harry Potter books then you're about to learn something!</p>\n<p>Catamorphisms are a great place to start on your journey towards understanding recursion schemes as a whole; they aren't as scary as they sound, the prefix <code>cata</code> comes from the Greek word meaning <code>downwards</code>, <code>morph</code> loosely means 'to change from one thing to another' so if we squint a bit we can pretend that <code>catamorphism</code> means to reduce something down. Catamorphisms take some <em>thing</em> with some associated structure and reduce it down to some new <em>thing</em> with <strong>less</strong> structure.</p>\n<p>If you've been using a functional programming language for a while you're probably familiar with other ways of reducing structure such as operations from the <code>Foldable</code> typeclass or perhaps using explicit recursion.</p>\n<p>Catamorphisms closely resemble the <code>foldr</code> function from <code>Data.List</code>; let's compare the two:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><span class=\"fu\">foldr</span><span class=\"ot\"> ::</span> <span class=\"dt\">Foldable</span> t  <span class=\"ot\">=&gt;</span> (a <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> b)   <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> t a <span class=\"ot\">-&gt;</span> b</a>\n<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\"><span class=\"ot\">cata ::</span>  <span class=\"dt\">Recursive</span> t <span class=\"ot\">=&gt;</span> (<span class=\"dt\">Base</span> t b <span class=\"ot\">-&gt;</span> b)      <span class=\"ot\">-&gt;</span> t   <span class=\"ot\">-&gt;</span> b</a></code></pre></div>\n<p>If we specialize them both to lists we get the following:</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb2-1\" title=\"1\"><span class=\"fu\">foldr</span><span class=\"ot\"> ::</span> (a <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> b)    <span class=\"ot\">-&gt;</span> b   <span class=\"ot\">-&gt;</span> [a] <span class=\"ot\">-&gt;</span> b</a>\n<a class=\"sourceLine\" id=\"cb2-2\" title=\"2\"><span class=\"ot\">cata  ::</span> (<span class=\"dt\">ListF</span> a b <span class=\"ot\">-&gt;</span> b) <span class=\"ot\">-&gt;</span>        [b] <span class=\"ot\">-&gt;</span> b</a></code></pre></div>\n<p>There are few things we notice right off the bat: the function we pass to each of them is slightly different; the function you pass to <code>foldr</code> combines the next element <code>a</code> and the accumulator <code>b</code>. <code>foldr</code> requires a default <code>b</code> in case the foldable structure is empty. The albegra you pass to <code>cata</code> must combine any accumulated <code>b</code>s from your structure with any new <code>a</code>s, and also must provide default behaviour in any base case which may occur.</p>\n<p>The first argument which cata takes (<code>Recursive t =&gt; (Base t b -&gt; b)</code>) is called an <strong>F-Algebra</strong>, it's a function which performs a single reduction step of a recursive operation. See the post on <a href=\"/articles/recursive/f-algebras\">F-Algebras</a> to dive in deeper!</p>\n<p>Handling the base case and collection of values into an algebra actually makes <code>cata</code> more powerful than <code>foldr</code>, we have knowledge of the structure of the data we're folding at each step and can make different decisions based on it, possibly handling recursive values differently based on their location in the structure (e.g. combine accumulators from the right branch of a binary tree differently from those in the left branch).</p>\n<p>Let's write the <code>sum :: [Int] -&gt; Int</code> function in a few different ways so we can compare approaches. We'll do one using <code>foldr</code>, one with explicit recursion and finally one with <code>cata</code>.</p>\n<p>Here's the simple <code>foldr</code> version:</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb3-1\" title=\"1\"><span class=\"ot\">sumFoldr ::</span> [<span class=\"dt\">Int</span>] <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb3-2\" title=\"2\">sumFoldr <span class=\"fu\">=</span> <span class=\"fu\">foldr</span> (<span class=\"fu\">+</span>) <span class=\"dv\">0</span></a></code></pre></div>\n<p>Here's one with explicit recursion:</p>\n<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb4-1\" title=\"1\"><span class=\"ot\">sumRecursive ::</span> [<span class=\"dt\">Int</span>] <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb4-2\" title=\"2\">sumRecursive []         <span class=\"fu\">=</span> <span class=\"dv\">0</span></a>\n<a class=\"sourceLine\" id=\"cb4-3\" title=\"3\">sumRecursive (n <span class=\"fu\">:</span> rest) <span class=\"fu\">=</span> n <span class=\"fu\">+</span> sumRecursive rest</a></code></pre></div>\n<p>Here's the slightly longer <code>cata</code> version</p>\n<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb5-1\" title=\"1\"><span class=\"ot\">sumCata ::</span> [<span class=\"dt\">Int</span>] <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb5-2\" title=\"2\">sumCata <span class=\"fu\">=</span> cata algebra</a>\n<a class=\"sourceLine\" id=\"cb5-3\" title=\"3\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb5-4\" title=\"4\"><span class=\"ot\">  algebra ::</span> <span class=\"dt\">ListF</span> <span class=\"dt\">Int</span> <span class=\"dt\">Int</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb5-5\" title=\"5\">  <span class=\"co\">-- Here we provide a default value for our base case</span></a>\n<a class=\"sourceLine\" id=\"cb5-6\" title=\"6\">  algebra <span class=\"dt\">Nil</span>               <span class=\"fu\">=</span> <span class=\"dv\">0</span></a>\n<a class=\"sourceLine\" id=\"cb5-7\" title=\"7\">  <span class=\"co\">-- We collapse one step of the list by adding</span></a>\n<a class=\"sourceLine\" id=\"cb5-8\" title=\"8\">  <span class=\"co\">-- the next element to the running total</span></a>\n<a class=\"sourceLine\" id=\"cb5-9\" title=\"9\">  algebra (<span class=\"dt\">Cons</span> next total) <span class=\"fu\">=</span> next <span class=\"fu\">+</span> total</a></code></pre></div>\n<p>So we can see here that the <code>cata</code> version is definitely longer for this particular case, using <code>cata</code> doesn't gain us much when we're operating on lists since they have no additional structure on top of what <code>Foldable</code> provides us via <code>toList</code>; but as we continue onwards to more complex structures we find that we have more power using an algebra than we do with the <code>Foldable</code> instance of structures.</p>\n<p>Let's upgrade our Lists to Trees to see how this plays out!</p>\n<p>Here's a data structure representing a <a href=\"https://en.wikipedia.org/wiki/Binary_tree\">Binary Tree</a> where each node contains a value. Notice that we're also deriving a <code>Foldable</code> instance for the structure here using <code>DeriveFoldable</code>.</p>\n<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb6-1\" title=\"1\"><span class=\"co\">-- Recursive binary tree with data at leaf nodes</span></a>\n<a class=\"sourceLine\" id=\"cb6-2\" title=\"2\"><span class=\"kw\">data</span> <span class=\"dt\">BinTree</span> a <span class=\"fu\">=</span> <span class=\"dt\">Branch</span> a (<span class=\"dt\">BinTree</span> a) (<span class=\"dt\">BinTree</span> a) <span class=\"fu\">|</span> <span class=\"dt\">Empty</span></a>\n<a class=\"sourceLine\" id=\"cb6-3\" title=\"3\">  <span class=\"kw\">deriving</span> (<span class=\"dt\">Show</span>, <span class=\"dt\">Eq</span>, <span class=\"dt\">Foldable</span>)</a></code></pre></div>\n<p>Now we'll write the recursive <code>Functor</code> version of the type for use with recursion schemes where each recursive occurance of the structure is replaced with a new type variable <code>r</code>.</p>\n<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb7-1\" title=\"1\"><span class=\"kw\">data</span> <span class=\"dt\">BinTreeF</span> a r <span class=\"fu\">=</span> <span class=\"dt\">BranchF</span> a r r <span class=\"fu\">|</span> <span class=\"dt\">EmptyF</span></a>\n<a class=\"sourceLine\" id=\"cb7-2\" title=\"2\">  <span class=\"kw\">deriving</span> (<span class=\"dt\">Show</span>, <span class=\"dt\">Eq</span>, <span class=\"dt\">Functor</span>)</a>\n<a class=\"sourceLine\" id=\"cb7-3\" title=\"3\"><span class=\"kw\">type</span> <span class=\"kw\">instance</span> <span class=\"dt\">Base</span> (<span class=\"dt\">BinTree</span> a) <span class=\"fu\">=</span> <span class=\"dt\">BinTreeF</span> a</a>\n<a class=\"sourceLine\" id=\"cb7-4\" title=\"4\"></a>\n<a class=\"sourceLine\" id=\"cb7-5\" title=\"5\"><span class=\"kw\">instance</span> <span class=\"dt\">Recursive</span> (<span class=\"dt\">BinTree</span> a) <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb7-6\" title=\"6\">  project <span class=\"dt\">Empty</span> <span class=\"fu\">=</span> <span class=\"dt\">EmptyF</span></a>\n<a class=\"sourceLine\" id=\"cb7-7\" title=\"7\">  project (<span class=\"dt\">Branch</span> a left right) <span class=\"fu\">=</span> <span class=\"dt\">BranchF</span> a left right</a>\n<a class=\"sourceLine\" id=\"cb7-8\" title=\"8\"></a>\n<a class=\"sourceLine\" id=\"cb7-9\" title=\"9\"><span class=\"kw\">instance</span> <span class=\"dt\">Corecursive</span> (<span class=\"dt\">BinTree</span> a) <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb7-10\" title=\"10\">  embed <span class=\"dt\">EmptyF</span> <span class=\"fu\">=</span> <span class=\"dt\">Empty</span></a>\n<a class=\"sourceLine\" id=\"cb7-11\" title=\"11\">  embed (<span class=\"dt\">BranchF</span> a left right) <span class=\"fu\">=</span> <span class=\"dt\">Branch</span> a left right</a></code></pre></div>\n<p>Great! That's a bit more interesting!</p>\n<p>To prove that our recursion schemes and algebras give new power over what Foldable brings we'll attempt to implement some standard tree traversals! If you're unfamiliar with the concept you can read up more about tree traversals on the <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\">Wiki page</a>!</p>\n<p>In short, we want to reduce a tree to a list, but there are several possible orderings to do it!</p>\n<p>It turns out that when we derive the <code>Foldable</code> class, the order of the fields in our constructor actually determines which traversal we get! Since we have the structure <code>Branch a (BinTree a) (BinTree a)</code> GHC will <strong>fold</strong> the 'a' first, then the left branch followed by the right, corresponding to a depth first traversal. That means our implementation of Depth-First-Search using foldable is simply:</p>\n<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb8-1\" title=\"1\"><span class=\"ot\">depthFirstFoldable ::</span> <span class=\"dt\">BinTree</span> a <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb8-2\" title=\"2\">depthFirstFoldable <span class=\"fu\">=</span> toList</a></code></pre></div>\n<p>Here's the equivalent version using <code>cata</code></p>\n<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb9-1\" title=\"1\"><span class=\"ot\">depthFirstCata ::</span> <span class=\"dt\">BinTree</span> a <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb9-2\" title=\"2\">depthFirstCata <span class=\"fu\">=</span> cata algebra</a>\n<a class=\"sourceLine\" id=\"cb9-3\" title=\"3\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb9-4\" title=\"4\"><span class=\"ot\">  algebra ::</span> <span class=\"dt\">BinTreeF</span> a [a] <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb9-5\" title=\"5\">  algebra <span class=\"dt\">EmptyF</span>          <span class=\"fu\">=</span> []</a>\n<a class=\"sourceLine\" id=\"cb9-6\" title=\"6\">  algebra (<span class=\"dt\">BranchF</span> a l r) <span class=\"fu\">=</span> [a] <span class=\"fu\">++</span> l <span class=\"fu\">++</span> r</a></code></pre></div>\n<p>Hopefully that's relatively stright forward! Now for the tricky bit, how do we define an <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\"><em>In Order</em></a> traversal using our Foldable instance? Sorry to break it to ya, but we <em>can't</em>! Our foldable instance only knows how to process all elements, there are no guarantees on ordering and there's no way for us to talk about the <strong>structure</strong> of the data as we fold! Using <code>cata</code> it's easy! Check it out:</p>\n<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb10-1\" title=\"1\"><span class=\"ot\">inOrderCata ::</span> <span class=\"dt\">BinTree</span> a <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb10-2\" title=\"2\">inOrderCata <span class=\"fu\">=</span> cata algebra</a>\n<a class=\"sourceLine\" id=\"cb10-3\" title=\"3\"> <span class=\"kw\">where</span></a>\n<a class=\"sourceLine\" id=\"cb10-4\" title=\"4\"><span class=\"ot\">  algebra ::</span> <span class=\"dt\">BinTreeF</span> a [a] <span class=\"ot\">-&gt;</span> [a]</a>\n<a class=\"sourceLine\" id=\"cb10-5\" title=\"5\">  algebra <span class=\"dt\">EmptyF</span>          <span class=\"fu\">=</span> []</a>\n<a class=\"sourceLine\" id=\"cb10-6\" title=\"6\">  algebra (<span class=\"dt\">BranchF</span> a l r) <span class=\"fu\">=</span> l <span class=\"fu\">++</span> [a] <span class=\"fu\">++</span> r</a></code></pre></div>\n<p>This shows how recursion-schemes and the use of <strong>algebras</strong> helps give us more <strong>power</strong> by having knowledge of our data's <strong>structure</strong> at the cost of a little boiler-plate.</p>","title":"Basic Catamorphisms","why":"Catamorphisms allow you to express recursive operations elegantly","section":"Recursive"},{"what":"F-Algebras reduce data embedded in a structure (Functor) down to a single value","slug":"f-algebras","sortKey":"1","url":"/articles/recursive/f-algebras","content":"<h1 id=\"f-algebras\">F-Algebras</h1>\n<p><code>Algebra</code> is unfortunately an extremely overloaded term, but here we're going to specifically be talking about <code>F-Algebras</code>. In a nutshell, an <code>F-Algebra</code> is simply any function of type <code>(f a -&gt; a)</code>. Honestly, if that makes sense to you, you can probably stop there and go back to whatever you were trying to do. If you want a bit more background on it feel free to keep reading!</p>\n<p>In the context of the Recursion Schemes <code>F-Algebras</code> are passed to combinators to show them how you'd like to collapse down a single 'layer' of structure. The library can then apply this reduction iteratively until the entire structure has been collapsed.</p>\n<p>Here's an example of an <code>F-Algebra</code> over lists which shows how to fold a single 'layer' of the <code>ListF</code> functor which contains an <code>Int</code> as data, and to combine it with the recursive result of summing the rest of the list. In the <code>Nil</code> case we must still return an <code>Int</code> somehow so we use <code>0</code> as the sum of an empty list is <code>0</code>.</p>\n<p>The signature of our algebra is <code>ListF Int Int -&gt; Int</code> which means the <code>f</code> of this <code>F-Algebra</code> is <code>ListF Int</code> . We provide a way to collapse this structure containing <code>Int</code>s into a single <code>Int</code></p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><a class=\"sourceLine\" id=\"cb1-1\" title=\"1\"><span class=\"ot\">sumListFAlgebra ::</span> <span class=\"dt\">ListF</span> <span class=\"dt\">Int</span> <span class=\"dt\">Int</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></a>\n<a class=\"sourceLine\" id=\"cb1-2\" title=\"2\">sumListFAlgebra (<span class=\"dt\">Cons</span> val total) <span class=\"fu\">=</span> val <span class=\"fu\">+</span> total</a>\n<a class=\"sourceLine\" id=\"cb1-3\" title=\"3\">sumListFAlgebra <span class=\"dt\">Nil</span>              <span class=\"fu\">=</span> <span class=\"dv\">0</span></a>\n<a class=\"sourceLine\" id=\"cb1-4\" title=\"4\"></a></code></pre></div>\n<p>The Recursion Schemes functions accept algebras as arguments to perform their function, so you can avoid a lot of work by writing a simple algebra which expresses a single step of your problem and let the library figure out the rest for you.</p>","title":"F-Algebras","why":"F-Algebras are typically used as arguments to Recursive recursion-schemes","section":"Recursive"}]